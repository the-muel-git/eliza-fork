import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import { exec } from 'child_process';

const execAsync = promisify(exec);

interface CharacterConfig {
  plugins: string[];
  clients: string[];
  modelProvider: string;
  settings: {
    database?: {
      provider: string;
    };
    voice?: {
      provider: string;
    };
  };
}

interface PackageInfo {
  name: string;
  required: boolean;
  reason?: string;
}

class PackageManager {
  private npmignorePath: string;
  private packagesDir: string;
  private characterPath: string;
  private manualInclusions: string[] = [];
  private manualExclusions: string[] = [];

  constructor(workspaceRoot: string, characterPath: string) {
    this.npmignorePath = path.join(workspaceRoot, '.npmignore');
    this.packagesDir = path.join(workspaceRoot, 'packages');
    this.characterPath = characterPath;
  }

  private async readCharacterConfig(): Promise<CharacterConfig> {
    const content = await fs.promises.readFile(this.characterPath, 'utf-8');
    return JSON.parse(content);
  }

  private async getPackageDirectories(): Promise<string[]> {
    const entries = await fs.promises.readdir(this.packagesDir, { withFileTypes: true });
    return entries
      .filter(entry => entry.isDirectory())
      .map(dir => dir.name);
  }

  private isRequiredPackage(packageName: string, config: CharacterConfig): [boolean, string?] {
    // Core is always required
    if (packageName === 'core') {
      return [true, 'Core package'];
    }

    // Check clients
    if (packageName.startsWith('client-')) {
      const client = packageName.replace('client-', '');
      if (config.clients.includes(client)) {
        return [true, `Required by character clients: ${client}`];
      }
    }

    // Check plugins
    if (packageName.startsWith('plugin-')) {
      const plugin = `@elizaos/${packageName}`;
      if (config.plugins.includes(plugin)) {
        return [true, `Required by character plugins`];
      }
    }

    // Check database adapter
    if (packageName.startsWith('adapter-')) {
      const adapter = packageName.replace('adapter-', '');
      if (config.settings.database?.provider === adapter) {
        return [true, `Required by database provider: ${adapter}`];
      }
    }

    // Check voice provider
    if (packageName.startsWith('plugin-') && config.settings.voice?.provider) {
      if (packageName === `plugin-${config.settings.voice.provider}`) {
        return [true, `Required by voice provider: ${config.settings.voice.provider}`];
      }
    }

    // Check manual inclusions
    if (this.manualInclusions.includes(packageName)) {
      return [true, 'Manually included'];
    }

    // Check manual exclusions
    if (this.manualExclusions.includes(packageName)) {
      return [false, 'Manually excluded'];
    }

    return [false];
  }

  public async includePackage(packageName: string) {
    this.manualInclusions.push(packageName);
    this.manualExclusions = this.manualExclusions.filter(p => p !== packageName);
    await this.updateNpmignore();
  }

  public async excludePackage(packageName: string) {
    this.manualExclusions.push(packageName);
    this.manualInclusions = this.manualInclusions.filter(p => p !== packageName);
    await this.updateNpmignore();
  }

  private async updateNpmignore() {
    const config = await this.readCharacterConfig();
    const packages = await this.getPackageDirectories();
    const packageInfo = await this.analyzePackages(config);

    const requiredPackages = packageInfo
      .filter(p => p.required)
      .map(p => p.name);

    const npmignoreContent = `# This file is auto-generated by manage-packages.ts
# Keep only the packages we need
packages/*
${requiredPackages.map(p => `!packages/${p}`).join('\n')}

# Debug and cache directories
packages/debug_audio/
packages/content_cache/

# Development files
**/*.test.ts
**/*.spec.ts
**/test/
**/tests/
**/__tests__/
**/coverage/
**/.nyc_output/

# Source maps and TypeScript files
**/*.map
**/*.ts
!**/*.d.ts

# Development configs
**/.eslintrc*
**/.prettierrc*
**/tsconfig.json
**/jest.config.js

# Documentation
**/docs/
**/README.md
**/CHANGELOG.md
**/LICENSE

# Build artifacts
**/dist/
**/.turbo/
**/node_modules/
`;

    await fs.promises.writeFile(this.npmignorePath, npmignoreContent);
  }

  public async analyzePackages(config?: CharacterConfig): Promise<PackageInfo[]> {
    if (!config) {
      config = await this.readCharacterConfig();
    }

    const packages = await this.getPackageDirectories();
    return packages.map(pkg => {
      const [required, reason] = this.isRequiredPackage(pkg, config!);
      return {
        name: pkg,
        required,
        reason
      };
    });
  }

  public async printAnalysis() {
    const packageInfo = await this.analyzePackages();
    
    console.log('\nPackage Analysis:');
    console.log('=================');
    
    console.log('\nRequired Packages:');
    packageInfo
      .filter(p => p.required)
      .forEach(p => {
        console.log(`✅ ${p.name}${p.reason ? ` (${p.reason})` : ''}`);
      });

    console.log('\nExcluded Packages:');
    packageInfo
      .filter(p => !p.required)
      .forEach(p => {
        console.log(`❌ ${p.name}`);
      });
  }
}

// CLI interface
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  const packageName = args[1];

  const workspaceRoot = process.cwd();
  const characterPath = path.join(workspaceRoot, 'characters/eternalai.character.json');
  
  const manager = new PackageManager(workspaceRoot, characterPath);

  switch (command) {
    case 'analyze':
      await manager.printAnalysis();
      break;
    case 'include':
      if (!packageName) {
        console.error('Please specify a package name to include');
        process.exit(1);
      }
      await manager.includePackage(packageName);
      console.log(`Included package: ${packageName}`);
      break;
    case 'exclude':
      if (!packageName) {
        console.error('Please specify a package name to exclude');
        process.exit(1);
      }
      await manager.excludePackage(packageName);
      console.log(`Excluded package: ${packageName}`);
      break;
    default:
      console.log(`
Usage:
  pnpm manage-packages analyze             # Show package analysis
  pnpm manage-packages include <package>   # Include a package
  pnpm manage-packages exclude <package>   # Exclude a package
      `);
  }
}

main().catch(console.error); 